#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\boxbgcolor #d4d4d4
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 0
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\bullet 0 0 15 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
JSFX Language Reference
\end_layout

\begin_layout Author
REAPER 5.0+
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
This is a reference guide to programming audio-oriented effects for REAPER
 using JS.
 JS is a scripting language which is compiled on the fly and allows you
 to modify and/or generate audio and MIDI, as well as draw custom vector
 based UI and analysis displays.
 JS effects are simple text files, which when loaded in REAPER become full
 featured plug-ins.
 You can try loading existing JS effects and since they are distributed
 in source form, you can also edit existing effects to suit your needs (we
 recommend if editing an existing effect, you save it as something with
 a new name--if you do not you may lose your changes when upgrading REAPER).
 This guide will offer an outline of the structure of the text file used
 by JS, the syntax for writing code, as well as a list of all functions
 and special variables available for use.
 
\end_layout

\begin_layout Chapter
JSFX File Structure
\end_layout

\begin_layout Section
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Description Lines
\end_layout

\end_inset

Description Lines
\end_layout

\begin_layout Standard
JS Effects are text files that are composed of some description lines followed
 by one or more code sections.
 Semi-colons are not used to terminate these lines.
\begin_inset Newline newline
\end_inset

The description lines that can be specified are:
\end_layout

\begin_layout Subsection

\family typewriter
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
desc
\end_layout

\end_inset


\color blue
desc:Effect Description
\end_layout

\begin_layout Standard
This line should be specified once and only once, and defines the name of
 the effect which will be displayed to the user.
 Ideally this line should be the first line of the file, so that it can
 be quickly identified as a JS file.
\end_layout

\begin_layout Subsection

\family typewriter
\size large
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
slider!description lines
\end_layout

\end_inset


\size default
\color blue
slider1:5<0,10,1>Slider Description
\end_layout

\begin_layout Standard
You can specify multiple of these lines (from 1-64 currently) to specify
 parameters that the user can control using standard UI controls (typically
 a fader and text input, but this can vary, see below).
 These parameters are also automatable from REAPER.
 
\end_layout

\begin_layout Standard
In the above example, the first 1 specifies the first parameter, 5 is the
 default value of the parameter, 0 is the minimum value, 10 is the maximum
 value, and 1is the change increment.
 slider description is what is displayed to the user.
\end_layout

\begin_layout Standard
There are additional extended slider syntaxes.
\begin_inset Newline newline
\end_inset

One is: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size small
\color blue
slider1:0<0,5,1{zerolabel,onelabel,twolabel,threelabel,fourlabel,fivelabel}>some
 setting
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will show this parameter with a list of options from "zerolabel" to
 "fivelabel".
 Note that these parameters should be set to start at 0 and have a change
 increment of 1, as shown above.
 
\begin_inset Newline newline
\end_inset

Another extended syntax is: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\color blue
slider1:/some_path:default_value:slider description
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also hide sliders by prefixing their names with "-":
\family typewriter
\size small
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\color blue
slider1:0<0,127,1>-Hidden parameter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Such parameters will not be visible in the plug-in UI but still be active,
 automatable, etc.
\end_layout

\begin_layout Subsection

\family typewriter
\color blue
\begin_inset Index idx
status open

\begin_layout Plain Layout
in_pin
\end_layout

\end_inset

in_pin:Name / 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
out_pin
\end_layout

\end_inset

out_pin:Name
\end_layout

\begin_layout Standard
These optional lines export names for each of the JS pins (effect channels),
 for display in REAPER's plug-in pin connector dialog.
 If the only named 
\family typewriter
\color black
in_pin
\family default
\color inherit
 or 
\family typewriter
\color black
out_pin
\family default
\color inherit
 is labeled "none", REAPER will know that the effect has no audio inputs
 and/or outputs, which enables some processing optimizations.
 MIDI-only FX should specify
\family typewriter
\size small
 
\size default
\color black
in_pin:none
\family default
\color inherit
 and 
\family typewriter
\color black
out_pin:none
\family default
\color inherit
.
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
filename
\end_layout

\end_inset


\family typewriter
\color blue
filename:0,filename.wav
\end_layout

\begin_layout Standard
These lines can be used to specify filenames which can be used by code later.
 These definitions include 0 (the index) and a filename.
 The indices must be listed in order without gaps -- i.e.
 the first should always be 0, the second (if any) always should be 1, and
 so on.
 
\end_layout

\begin_layout Standard
To use for generic data files, the files should be located in the REAPER
\backslash
Data directory, and these can be opened with file_open(), passing the filename
 index.
 
\end_layout

\begin_layout Standard
You may also specify a PNG file.
 If you specify a file ending in .png, it will be opened from the same directory
 as the effect, and you can use the filename index as a parameter to gfx_blit().
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
options:
\end_layout

\end_inset


\family typewriter
\color blue
options:option_dependent_syntax
\end_layout

\begin_layout Standard
This line can be used to specify JSFX options:
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
options:!gmem
\end_layout

\end_inset


\family typewriter
\color blue
options:gmem=someUniquelyNamedSpace
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This option allows plugins to allocate their own global shared buffer, see
 gmem[].
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
options:!want_all_kb
\end_layout

\end_inset


\family typewriter
\color blue
options:want_all_kb
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Enables the "Send all keyboard input to plug-in" option for new instances
 of the plug-in, see gfx_getchar().
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
import
\end_layout

\end_inset


\family typewriter
\color blue
import filename
\end_layout

\begin_layout Standard
You can specify a filename to import (this filename will be searched within
 the JS effect directory).
 Importing files via this directive will have any functions defined in their
 @init sections available to the local effect.
 Additionally, if the imported file implements other sections (such as @sample,
 etc), and the importing file does not implement those sections, the imported
 version of those sections will be used.
 
\end_layout

\begin_layout Standard
Note that files that are designed for import only (such as function libraries)
 should ideally be named xyz.jsfx-inc, as these will be ignored in the user
 FX list in REAPER.
\end_layout

\begin_layout Section
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Code Sections
\end_layout

\end_inset

Code Sections
\end_layout

\begin_layout Standard
Following the description lines, there should be code sections.
 All of the code sections are optional (though an effect without any would
 likely have limited use).
 Code sections are declared by a single line, then followed by as much code
 as needed until the end of the file, or until the next code section.
 Each code section can only be defined once.
 The following code sections are currently used:
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
@init
\end_layout

\end_inset


\family typewriter
\color blue
@init
\end_layout

\begin_layout Standard
The code in the @init section gets executed on effect load, on samplerate
 changes, and on start of playback.
 If you wish this code to not execute on start of playback, you can set
 ext_noinit to 1.0, and it will only execute on load or samplerate change
 (and not on playback start/stop).
 All memory and variables are zero on load, and if no @serialize code section
 is defined, then all memory and variables will be re-zeroed before calling
 @init (on sample rate change, playback start/stop/etc).
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
@slider
\end_layout

\end_inset


\family typewriter
\color blue
@slider
\end_layout

\begin_layout Standard
The code in the @slider section gets executed following an @init, or when
 a parameter (slider) changes.
 Ideally code in here should detect when a slider has changed, and adapt
 to the new parameters (ideally avoiding clicks or glitches).
 The parameters defined with sliderX: can be read using the variables sliderX.
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
@block
\end_layout

\end_inset


\family typewriter
\color blue
@block
\end_layout

\begin_layout Standard
The code in the @block section is executed before processing each sample
 block.
 Typically, a block is whatever length as defined by the audio hardware,
 or anywhere from 128-2048 samples.
 In this code section, the samplesblock variable will be valid (and set
 to the size of the upcoming block).
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
@sample
\end_layout

\end_inset


\family typewriter
\color blue
@sample
\end_layout

\begin_layout Standard
The code in the @sample section is executed for every PCM audio sample.
 This code can analyze, process, or synthesize, by reading, modifying, or
 writing to the variables spl0, spl1, ...
 spl63.
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
@serialize
\end_layout

\end_inset


\family typewriter
\color blue
@serialize
\end_layout

\begin_layout Standard
The code in the @serialize section is executed when the plug-in needs to
 load or save some extended state.
 The sliderX parameters are saved automatically, but if there are internal
 state variables or memory that should be saved, they should be saved/restored
 here using file_var() or file_mem() (passing an argument of 0 for the file
 handle).
 (If the code needs to detect whether it is saving or loading, it can do
 so with file_avail() (file_avail(0) will return <0 if it is writing).
 
\end_layout

\begin_layout Standard
Note when saving the state of variables or memory, they are stored in a
 more compact 32-bit representation, so a slight precision loss is possible.
 Note also that you should not clear any variables saved/loaded by @serialize
 in @init, as sometimes @init will be called following @serialize.
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
@gfx
\end_layout

\end_inset


\family typewriter
\color blue
@gfx [width] [height]
\end_layout

\begin_layout Standard
The @gfx section gets executed around 30 times a second when the plug-ins
 GUI is open.
 You can do whatever processing you like in this (Typically using gfx_*()).
 Note that this code runs in a separate thread from the audio processing,
 so you may have both running simultaneously which could leave certain variables
/RAM in an unpredictable state.
\end_layout

\begin_layout Standard
The @gfx section has two optional parameters, which can specify the desired
 width/height of the graphics area.
 Set either of these to 0 (or omit them) to specify that the code doesn't
 care what size it gets.
 Note that these are simply hints to request this size -- you may not always
 get the specified size.
 Your code in this section should use the gfx_w, gfx_h variables to actually
 determine drawing dimensions.
\end_layout

\begin_layout Chapter
Basic Code Reference
\end_layout

\begin_layout Section
Introduction to EEL2
\end_layout

\begin_layout Standard
The core of JSFX is custom code written in a simple language (called EEL2),
 which has many similarities to C.
 Code is written in one or more of the numerous code sections.
 Some basic features of this language are:
\end_layout

\begin_layout Itemize
Variables do not need to be declared, are by default global to the effect,
 and are all double-precision floating point.
\end_layout

\begin_layout Itemize
Basic operations including addition (+), subtraction (-), multiplication
 (*), division (/), and exponential (^)
\end_layout

\begin_layout Itemize
Bitwise operations including OR (|), AND (&), XOR (~), shift-left (<<),
 and shift-right-sign-extend (>>).
 These all convert to integer for calculation.
\end_layout

\begin_layout Itemize
Parentheses "(" and ")" can be used to clarify precedence, contain parameters
 for functions, and collect multiple statements into a single statement.
\end_layout

\begin_layout Itemize
A semicolon ";" is used to separate statements from each other (including
 within parentheses).
\end_layout

\begin_layout Itemize
A virtual local address space of about 8 million slots, which can be accessed
 via brackets "[" and "]".
\end_layout

\begin_layout Itemize
A shared global address space of about 1 million slots, accessed via gmem[].
 These words are shared between all JSFX plug-in instances.
\end_layout

\begin_layout Itemize
Shared global named variables, accessible via the "_global." prefix.
 These variables are shared between all JSFX plug-in instances.
\end_layout

\begin_layout Itemize
User definable functions, which can define private variables, parameters,
 and also can, optionally, access namespaced instance variables.
\end_layout

\begin_layout Itemize
Numbers are in normal decimal, however if you prefix an '$x' to them, they
 will be hexadecimal (i.e.
 $x90, $xDEADBEEF, etc).
\end_layout

\begin_layout Itemize
You may specify the ASCII value of a character using $'c' (where c is the
 character).
\end_layout

\begin_layout Itemize
If you wish to generate a mask of 1 bits in integer, you can use $~X, for
 example $~7 is 127, $~8 is 255, $~16 is 65535, etc.
 
\end_layout

\begin_layout Itemize
Comments can be specified using:
\begin_inset Newline newline
\end_inset

// comments to end of line
\begin_inset Newline newline
\end_inset

/* comments block of code that spans lines or is part of a line.
 */
\end_layout

\begin_layout Section
Operator Reference
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
[]
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
z=x[y]; 
\begin_inset Newline newline
\end_inset

x[y]=z;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may use brackets to index into memory that is local to your effect.
 Your effect has approximately 8 million (8,388,608) slots of memory and
 you may access them either with fixed offsets (i.e.
 16811[0]) or with variables (myBuffer[5]).
 The sum of the value to the left of the brackets and the value within the
 brackets is used to index memory.
 If a value in the brackets is omitted then only the value to the left of
 the brackets is used.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
z=gmem[y]; 
\begin_inset Newline newline
\end_inset

gmem[y]=z;
\family default
\size default
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If 'gmem' is specified as the left parameter to the brackets, then the global
 shared buffer is used, which is approximately 1 million (1,048,576) slots
 that are shared across all instances of all JSFX effects.
 
\end_layout

\begin_layout Standard
The plug-in can also specify a line (before code sections): options:gmem=someUni
quelyNamedSpace which will make gmem[] refer to a larger shared buffer,
 accessible by any plugin that uses 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
options:gmem=<the same name>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, if you have a single plug-in, or a few plug-ins that access the shared
 namespace, they can communicate without having to worry about other plug-ins.
 This option also increases the size of gmem[] to be 8 million entries (from
 the default 1 million).
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
!x
\end_layout

\begin_layout Standard
returns the logical NOT of the parameter (if the parameter is 0.0, returns
 1.0, otherwise returns 0.0).
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
-x
\end_layout

\begin_layout Standard
returns value with a reversed sign (-1 * value).
 • +value -- returns value unmodified.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x ^ y
\end_layout

\begin_layout Standard
returns the first parameter raised to the power of the second parameter.
 This is also available the function pow(x,y) 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x % y
\end_layout

\begin_layout Standard
divides two values as integers and returns the remainder.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x << y
\end_layout

\begin_layout Standard
converts both values to 32-bit integers, bitwise left shifts the first value
 by the second.
 Note that shifts by more than 32 or less than 0 produce undefined results.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x >> y
\end_layout

\begin_layout Standard
converts both values to 32-bit integers, bitwise right shifts the first
 value by the second, with sign-extension (negative values of y produce
 non-positive results).
 Note that shifts by more than 32 or less than 0 produce undefined results.
 -- REAPER 4.111+ 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x / y
\end_layout

\begin_layout Standard
divides two values and returns the quotient.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x * y
\end_layout

\begin_layout Standard
multiplies two values and returns the product.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x - y
\end_layout

\begin_layout Standard
subtracts two values and returns the difference.
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x + y
\end_layout

\begin_layout Standard
adds two values and returns the sum.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x | y
\end_layout

\begin_layout Standard
converts both values to integer, and returns bitwise OR of values.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x & y
\end_layout

\begin_layout Standard
converts both values to integer, and returns bitwise AND of values.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x ~ y
\end_layout

\begin_layout Standard
converts both values to 32 bit integers, bitwise XOR the values.
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x == y
\end_layout

\begin_layout Standard
compares two values, returns 1 if difference is less than 0.00001, 0 if not.
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x === y
\end_layout

\begin_layout Standard
compares two values, returns 1 if exactly equal, 0 if not.
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x != y
\end_layout

\begin_layout Standard
compares two values, returns 0 if difference is less than 0.00001, 1 if not.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x !== y
\end_layout

\begin_layout Standard
compares two values, returns 0 if exactly equal, 1 if not.
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x < y
\end_layout

\begin_layout Standard
compares two values, returns 1 if first parameter is less than second.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x > y
\end_layout

\begin_layout Standard
compares two values, returns 1 if first parameter is greater than second.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x <= y
\end_layout

\begin_layout Standard
compares two values, returns 1 if first is less than or equal to second.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x >= y
\end_layout

\begin_layout Standard
compares two values, returns 1 if first is greater than or equal to second.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x || y 
\end_layout

\begin_layout Standard
returns logical OR of values.
 If 'x' is nonzero, 'y' is not evaluated.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x && y
\end_layout

\begin_layout Standard
returns logical AND of values.
 If 'x' is zero, 'y' is not evaluated.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x ? y
\end_layout

\begin_layout Standard
how conditional branching is done -- similar to C's if/else
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x ? y : z
\size normal
\color inherit
 
\end_layout

\begin_layout Standard
If x is non-zero, executes and returns y, otherwise executes and returns
 z (or 0.0 if ': z' is not specified).
 
\end_layout

\begin_layout Standard
Note that the expressions used can contain multiple statements within parenthese
s, such as: 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
x % 5 ? ( 
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f += 1; 
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x *= 1.5; 
\end_layout

\begin_layout Plain Layout
) : ( 
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

f=max(3,f); 
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x=0; 
\end_layout

\begin_layout Plain Layout
); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x = y
\end_layout

\begin_layout Standard
assigns the value of 'y' to 'x'.
 'y' can be a variable or an expression.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x *= y
\end_layout

\begin_layout Standard
multiplies two values and stores the product back into 'x'.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x /= y
\end_layout

\begin_layout Standard
divides two values and stores the quotient back into 'x'.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x %= y
\end_layout

\begin_layout Standard
divides two values as integers and stores the remainder back into 'x'.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x ^= y
\end_layout

\begin_layout Standard
raises x to the y-th power, saves back to 'x' 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x += y
\end_layout

\begin_layout Standard
adds two values and stores the sum back into 'x'.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x -= y
\end_layout

\begin_layout Standard
subtracts 'y' from 'x' and stores the difference into 'x'.
 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x |= y
\end_layout

\begin_layout Standard
converts both values to integer, and stores the bitwise OR into 'x' 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x &= y
\end_layout

\begin_layout Standard
converts both values to integer, and stores the bitwise AND into 'x' 
\end_layout

\begin_layout Subsubsection

\family typewriter
\size large
\color blue
x ~= y
\end_layout

\begin_layout Standard
converts both values to integer, and stores the bitwise XOR into 'x' --
 REAPER 4.25+
\end_layout

\begin_layout Subsection
Notes for C programmers
\end_layout

\begin_layout Itemize
( and ) (vs { } ) -- enclose multiple statements, and the value of that
 expression is the last statement within the block:
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
z = ( 
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

a = 5;
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b = 3; 
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

a+b; 
\begin_inset Newline newline
\end_inset

); // z will be set to 8, for example
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Conditional branching is done using the ? or ?: operator, rather than if()/else.
 
\begin_inset Newline newline
\end_inset


\family typewriter
\size footnotesize
a < 5 ? b = 6; // if a is less than 5, set b to 6 
\begin_inset Newline newline
\end_inset

a < 5 ? b = 6 : c = 7; //if a is less than 5, set b to 6, otherwise set
 c to 7 
\begin_inset Newline newline
\end_inset

a < 5 ? ( // if a is less than 5, set b to 6 and c to 7 
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b = 6; 
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

c = 7; 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

);
\end_layout

\begin_layout Itemize
The ? and ?: operators can also be used as the lvalue of expressions: 
\begin_inset Newline newline
\end_inset


\family typewriter
\size footnotesize
(a < 5 ? b : c) = 8; // if a is less than 5, set b to 8, otherwise set c
 to 8
\end_layout

\begin_layout Section
Simple Math Functions
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
sin
\end_layout

\end_inset

sin(angle)
\end_layout

\begin_layout Standard
returns the Sine of the angle specified (specified in radians -- to convert
 from degrees to radians, multiply by $pi/180, or 0.017453) 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
cos
\end_layout

\end_inset

cos(angle)
\end_layout

\begin_layout Standard
returns the Cosine of the angle specified (specified in radians).
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
tan
\end_layout

\end_inset

tan(angle)
\end_layout

\begin_layout Standard
returns the Tangent of the angle specified (specified in radians).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
asin
\end_layout

\end_inset

asin(x)
\end_layout

\begin_layout Standard
returns the Arc Sine of the value specified (return value is in radians).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
acos
\end_layout

\end_inset

acos(x)
\end_layout

\begin_layout Standard
returns the Arc Cosine of the value specified (return value is in radians).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
atan
\end_layout

\end_inset

atan(x)
\end_layout

\begin_layout Standard
returns the Arc Tangent of the value specified (return value is in radians).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
atan2
\end_layout

\end_inset

atan2(x,y)
\end_layout

\begin_layout Standard
returns the Arc Tangent of x divided by y (return value is in radians).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
sqr
\end_layout

\end_inset

sqr(x)
\end_layout

\begin_layout Standard
returns the square of the parameter (similar to x*x, though only evaluating
 x once).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
sqrt
\end_layout

\end_inset

sqrt(x)
\end_layout

\begin_layout Standard
returns the square root of the parameter.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
pow
\end_layout

\end_inset

pow(x,y) 
\end_layout

\begin_layout Standard
returns the first parameter raised to the second parameter-th power.
 Identical in behavior and performance to the ^ operator.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
exp
\end_layout

\end_inset

exp(x)
\end_layout

\begin_layout Standard
returns the number e (approx 2.718) raised to the parameter-th power.
 This function is significantly faster than pow() or the ^ operator 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
log
\end_layout

\end_inset

log(x)
\end_layout

\begin_layout Standard
returns the natural logarithm (base e) of the parameter.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
log10
\end_layout

\end_inset

log10(x)
\end_layout

\begin_layout Standard
returns the logarithm (base 10) of the parameter.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
abs
\end_layout

\end_inset

abs(x)
\end_layout

\begin_layout Standard
returns the absolute value of the parameter.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
min
\end_layout

\end_inset

min(x,y)
\end_layout

\begin_layout Standard
returns the minimum value of the two parameters.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
max
\end_layout

\end_inset

max(x,y)
\end_layout

\begin_layout Standard
returns the maximum value of the two parameters.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
sign
\end_layout

\end_inset

sign(x)
\end_layout

\begin_layout Standard
returns the sign of the parameter (-1, 0, or 1).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
rand
\end_layout

\end_inset

rand(x)
\end_layout

\begin_layout Standard
returns a psuedorandom number between 0 and the parameter.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
floor
\end_layout

\end_inset

floor(x)
\end_layout

\begin_layout Standard
rounds the value to the lowest integer possible (floor(3.9)==3, floor(-3.1)==-4).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
ceil
\end_layout

\end_inset

ceil(x)
\end_layout

\begin_layout Standard
rounds the value to the highest integer possible (ceil(3.1)==4, ceil(-3.9)==-3).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
invsqrt
\end_layout

\end_inset

invsqrt(x)
\end_layout

\begin_layout Standard
returns a fast inverse square root (1/sqrt(x)) approximation of the parameter.
\end_layout

\begin_layout Section
Time Functions
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
time
\end_layout

\end_inset

time([v])
\end_layout

\begin_layout Standard
REAPER 4.60+ Returns the current time as seconds since January 1, 1970.
 1 second granularity.
 If a parameter is specified, it will be set to the timestamp.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
time_precise
\end_layout

\end_inset

time_precise([v])
\end_layout

\begin_layout Standard
REAPER 4.60+ Returns a system-specific timestamp in seconds.
 Granularity is system-defined, but generally much less than 1 millisecond.
 Useful for benchmarking.
 If a parameter is specified, it will be set to the timestamp.
\end_layout

\begin_layout Chapter
Special Variables
\end_layout

\begin_layout Section
Basic Functionality
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
splX
\end_layout

\end_inset


\family typewriter
\size normal
spl0, spl1 ...
 spl63
\end_layout

\begin_layout Paragraph*
Context: @sample only
\end_layout

\begin_layout Paragraph*
Usage: read/write
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The variables spl0 and spl1 represent the current left and right samples
 in @sample code.
 The normal +0dB range is -1.0 ..
 1.0, but overs are allowed (and will eventually be clipped if not reduced
 by a later effect).
 On a very basic level, these values represent the speaker position at the
 point in time, but if you need more information you should do more research
 on PCM audio.
 If the effect is operating on a track that has more than 2 channels, then
 spl2..splN will be set with those channels values as well.
 If you do not modify a splX variable, it will be passed through unmodified.
 See also spl(x) below, though splX is generally slightly faster than spl(X).
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
spl(X)
\end_layout

\end_inset


\family typewriter
\size normal
spl(channel_index)
\end_layout

\begin_layout Paragraph*
Context: @sample only
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
If you wish to programmatically choose which sample to access, use this
 function (rather than splX).
 This is slightly slower than splX, however has the advantage that you can
 do spl(variable) (enabling easily configurable channel mappings).
 Valid syntaxes include: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
spl(channelindex)=somevalue; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
spl(5)+=spl(3);
\end_layout

\begin_layout Subsection*
\begin_inset Index idx
status open

\begin_layout Plain Layout
slider!sliderX
\end_layout

\end_inset


\family typewriter
\size normal
slider1, slider2 ...
 slider64
\end_layout

\begin_layout Paragraph*
Context: available everywhere
\end_layout

\begin_layout Paragraph*
Usage: read/write
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The variables slider1, slider2, ...
 slider64 allow interaction between the user and the effect, allowing the
 effects parameters to be adjusted by the user and likewise allow the effect
 to modify the parameters shown to the user (if you modify sliderX in a
 context other than @slider then you should call sliderchange(sliderX) to
 notify JS to refresh the control).
 The values of these sliders are purely effect-defined, and will be shown
 to the user, as well as tweaked by the user.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
slider!slider(X)
\end_layout

\end_inset


\family typewriter
\size normal
slider(slider_index)
\end_layout

\begin_layout Paragraph*
Context: available everywhere
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
If you wish to programmatically choose which slider to access, use this
 function (rather than sliderX).
 Valid syntaxes include: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
val = slider(sliderindex); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
slider(i) = 1;
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
slider!slider_next_chg
\end_layout

\end_inset


\family typewriter
\size normal
slider_next_chg(slider_index,nextval)
\end_layout

\begin_layout Paragraph*
Context: @block, @sample
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Used for sample-accurate automation.
 Each call will return a sample offset, and set nextval to the value at
 that sample offset.
 Returns a non-positive value if no changes (or no more changes) are available.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
trigger
\end_layout

\end_inset


\family typewriter
\size normal
trigger
\end_layout

\begin_layout Paragraph*
Context: @block, @sample
\end_layout

\begin_layout Paragraph*
Usage: read/write
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The trigger variable provides a facility for triggering effects.
 If this variable is used in an effect, the UI will show 10 trigger buttons,
 which when checked will result in the appropriate bit being set in this
 variable.
 
\end_layout

\begin_layout Standard
For example, to check for trigger 5 (triggered also by the key '5' on the
 keyboard): 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

isourtrig = trigger & (2^5); 
\end_layout

\begin_layout Standard
Conversely, to set trigger 5: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

trigger |= 2^5; 
\end_layout

\begin_layout Standard
Or, to clear trigger 5: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

trigger & (2^5) ? trigger -= 2^5;
\family default
\size default
 
\end_layout

\begin_layout Standard
It is recommended that you use this variable in @block, but only sparingly
 in @sample.
 
\end_layout

\begin_layout Section
Audio and Transport State
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
srate
\end_layout

\end_inset

srate
\end_layout

\begin_layout Paragraph
Context: available everywhere
\end_layout

\begin_layout Paragraph
Usage: read-only
\end_layout

\begin_layout Standard
The srate variable is set by the system to whatever the current sampling
 frequency is set to (usually 44100 to 192000).
 Generally speaking your @init code section will be called when this changes,
 though it's probably a good idea not to depend too much on that.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
num_ch
\end_layout

\end_inset

num_ch 
\end_layout

\begin_layout Paragraph*
Context: most contexts (see comments) 
\end_layout

\begin_layout Paragraph*
Usage: read-only
\end_layout

\begin_layout Standard
Specifies the number of channels available (usually 2).
 Note however splXX are still available even if this count is less, their
 inputs/outputs are just ignored.
 You can change the channel count available via in_pin:/out_pin: lines.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
samplesblock
\end_layout

\end_inset

samplesblock slider_automate(mask or sliderX)
\end_layout

\begin_layout Paragraph
Context: most contexts (see comments) 
\end_layout

\begin_layout Paragraph
Usage: read-only
\end_layout

\begin_layout Standard
The samplesblock variable can be used within @block code to see how many
 samples will come before the next @block call.
 It may also be valid in other contexts (though your code should handle
 invalid values in other contexts with grace).
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
tempo
\end_layout

\end_inset

tempo
\family default
\size default
 
\end_layout

\begin_layout Paragraph
Context: @block, @sample 
\end_layout

\begin_layout Paragraph
Usage: read-only 
\end_layout

\begin_layout Standard
The current project tempo, in "bpm".
 An example value would be 120.0.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
play
\end_layout

\end_inset

play_state 
\end_layout

\begin_layout Paragraph
Context: @block, @sample 
\end_layout

\begin_layout Paragraph
Usage: read-only 
\end_layout

\begin_layout Standard
The current playback state of REAPER 0=stopped, <0=error, 1=playing, 2=paused,
 5=recording, 6=record paused
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
play_position
\end_layout

\end_inset

play_position 
\end_layout

\begin_layout Paragraph
Context: @block, @sample 
\end_layout

\begin_layout Paragraph
Usage: read-only 
\end_layout

\begin_layout Standard
The current playback position in REAPER (as of last @block), in seconds.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
beat_position
\end_layout

\end_inset

beat_position 
\end_layout

\begin_layout Paragraph
Context: @block, @sample 
\end_layout

\begin_layout Paragraph
Usage: read-only.
 
\end_layout

\begin_layout Standard
The current playback position (as of last @block) in REAPER, in beats (beats
 = quarter notes in /4 time signatures).
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
ts_num
\end_layout

\end_inset

ts_num
\family default
\size default
 
\end_layout

\begin_layout Paragraph*
Context: @block, @sample 
\end_layout

\begin_layout Paragraph
Usage: read-only 
\end_layout

\begin_layout Standard
The current time signature numerator, i.e.
 3.0 if using 3/4 time.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
ts_denom
\end_layout

\end_inset

ts_denom 
\end_layout

\begin_layout Paragraph
Context: @block, @sample 
\end_layout

\begin_layout Paragraph*
Usage: read-only 
\end_layout

\begin_layout Standard
The current time signature denominator, i.e.
 4.0 if using 3/4 time.
\end_layout

\begin_layout Section
Extended Functionality
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
ext_noinit
\family default
\size default
 
\end_layout

\begin_layout Paragraph
Context: @init only 
\end_layout

\begin_layout Standard
Set this variable to 1.0 in your @init section if you do not wish for @init
 to be called (and variables/RAM to be possibly cleared) on every transport
 start.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
ext_nodenorm 
\end_layout

\begin_layout Paragraph
Context: @init only 
\end_layout

\begin_layout Standard
Set this variable to 1.0 in your @init section if you do not wish to have
 anti-denormal noise added to input.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
reg00-reg99 
\end_layout

\begin_layout Paragraph
Context: available everywhere 
\end_layout

\begin_layout Paragraph
Usage: read/write 
\end_layout

\begin_layout Standard
The 100 variables reg00, reg01, reg02, ..
 reg99 are shared across all effects and can be used for inter-effect communicat
ion.
 Their use should be documented in the effect descriptions to avoid collisions
 with other effects.
 regXX aliases to _global.regXX.
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
_global.* -- REAPER 4.5+
\family default
\size default
 
\end_layout

\begin_layout Paragraph
Context: available everywhere 
\end_layout

\begin_layout Paragraph
Usage: read/write 
\end_layout

\begin_layout Standard
Like regXX, _global.* are variables shared between all instances of all effects.
\end_layout

\begin_layout Section
Delay Compensation
\end_layout

\begin_layout Subsection
pdc_delay 
\end_layout

\begin_layout Paragraph
Context: @block, @slider 
\end_layout

\begin_layout Paragraph
Usage: read-write 
\end_layout

\begin_layout Standard
The current delay added by the plug-in, in samples.
 Note that you shouldn’t change this too often.
 This specifies the amount of the delay that should be compensated, however
 you need to set the pdc_bot_ch and pdc_top_ch below to tell JS which channels
 should be compensated.
 
\end_layout

\begin_layout Subsection
pdc_bot_ch, pdc_top_ch 
\end_layout

\begin_layout Paragraph
Context: @block, @slider 
\end_layout

\begin_layout Paragraph
Usage: read-write 
\end_layout

\begin_layout Standard
The channels that are delayed by pdc_delay.
 For example: pdc_bot_ch=0; pdc_top_ch=2; // delays the first two channels
 (spl0/spl1).
 pdc_bot_ch=2; pdc_top_ch=5; // delays channels spl2,spl3, and spl4.
 (this is provided so that channels you dont delay can be properly synchronized
 by the host).
 
\end_layout

\begin_layout Subsection
pdc_midi 
\end_layout

\begin_layout Paragraph
Context: @block, @slider 
\end_layout

\begin_layout Paragraph
Usage: read-write 
\end_layout

\begin_layout Standard
If set to 1.0, this will delay compensate MIDI as well as any specified audio
 channels.
\end_layout

\begin_layout Chapter
Miscellaneous Functions
\end_layout

\begin_layout Section
MDCT/FFT Functions
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
mdct
\end_layout

\end_inset

mdct(start_index, size), 
\begin_inset Index idx
status open

\begin_layout Plain Layout
imdct
\end_layout

\end_inset

imdct(start_index, size)
\end_layout

\begin_layout Standard
Performs a modified DCT (or inverse in the case of imdct()) on the data
 in the local memory buffer at the offset specified by the first parameter.
 The second parameter controls the size of the MDCT, and it MUST be one
 of the following: 64, 128, 256, 512, 1024, 2048, or 4096.
 The MDCT takes the number of inputs provided, and replaces the first half
 of them with the results.
 The IMDCT takes size/2 inputs, and gives size results.
 
\end_layout

\begin_layout Standard
Note that the MDCT must NOT cross a 65,536 item boundary, so be sure to
 specify the offset accordingly.
 The MDCT/IMDCT provided also provide windowing, so your code is not required
 to window the overlapped results, but simply add them.
 See the example effects for more information.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

mdct(0, 512);
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
fft
\end_layout

\end_inset

fft(start_index, size), 
\begin_inset Index idx
status open

\begin_layout Plain Layout
ifft
\end_layout

\end_inset

ifft(start_index, size) 
\begin_inset Newline newline
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
fft_permute
\end_layout

\end_inset

fft_permute(index,size), 
\begin_inset Index idx
status open

\begin_layout Plain Layout
fft_permute
\end_layout

\end_inset

fft_ipermute(index,size)
\end_layout

\begin_layout Standard
Performs a FFT (or inverse in the case of ifft()) on the data in the local
 memory buffer at the offset specified by the first parameter.
 The size of the FFT is specified by the second parameter, which must be
 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768.
 The outputs are permuted, so if you plan to use them in-order, call fft_permute
(buffer, size) before and fft_ipermute(buffer,size) after your in-order
 use.
 Your inputs or outputs will need to be scaled down by 1/size, if used.
 
\end_layout

\begin_layout Standard
Note that the FFT/IFFT require real/imaginary input pairs (so a 256 point
 FFT actually works with 512 items).
 
\end_layout

\begin_layout Standard
Note that the FFT/IFFT must NOT cross a 65,536 item boundary, so be sure
 to specify the offset accordingly.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

buffer=0; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

fft(buffer, 512); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

fft_permute(buffer, 512); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

buffer[32]=0; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

fft_ipermute(buffer, 512); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

ifft(buffer, 512); // need to scale output by 1/512.0, too.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
convolve_c
\end_layout

\end_inset

convolve_c(dest,src,size)
\end_layout

\begin_layout Standard
Used to convolve two buffers, typically after FFTing them.
 convolve_c works with complex numbers.
 The sizes specify number of items (the number of complex number pairs).
 Note that the convolution must NOT cross a 65,536 item boundary, so be
 sure to specify the offset accordingly
\end_layout

\begin_layout Section
Memory Utility
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
memory!freembuf
\end_layout

\end_inset

freembuf(top)
\end_layout

\begin_layout Standard
The freembuf() function provides a facility for you to notify the memory
 manager that you are no longer using a portion of the local memory buffer.
 For example, if the user changed a parameter on your effect halving your
 memory requirements, you should use the lowest indices possible, and call
 this function with the highest index you are using plus 1, i.e.
 if you are using 128,000 items, you should call freembuf(128001); If you
 are no longer using any memory, you should call freembuf(0); Note that
 calling this does not guarantee that the memory is freed or cleared, it
 just provides a hint that it is OK to free it.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
memory!memcpy
\end_layout

\end_inset

memcpy(dest,src,length)
\end_layout

\begin_layout Standard
The memcpy() function provides the ability to quickly copy regions of the
 local memory buffer.
 If the buffers overlap and either buffer crosses a 65,536 item boundary,
 the results may be undefined.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
memory!memset
\end_layout

\end_inset

memset(dest,value,length)
\end_layout

\begin_layout Standard
The memset() function provides the ability to quickly set a region of the
 local memory buffer to a particular value.
\end_layout

\begin_layout Section
Stack
\end_layout

\begin_layout Standard
A small (approximately 4096 item) user stack is available for use in code
 (REAPER 4.25+):
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
stack!stack_push
\end_layout

\end_inset

stack_push(value) 
\end_layout

\begin_layout Standard
Pushes value onto the user stack, returns a reference to the value.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
stack!stack_pop
\end_layout

\end_inset

stack_pop(value) 
\end_layout

\begin_layout Standard
Pops a value from the user stack into value, or into a temporary buffer
 if value is not specified, and returns a reference to where the stack was
 popped.
 Note that no checking is done to determine if the stack is empty, and as
 such stack_pop() will never fail.
\end_layout

\begin_layout Subsection*

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
stack!stack_peek
\end_layout

\end_inset

stack_peek(index) 
\end_layout

\begin_layout Standard
Returns a reference to the item on the top of the stack (if index is 0),
 or to the Nth item on the stack if index is greater than 0.
\end_layout

\begin_layout Subsection*

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
stack!stack_exch
\end_layout

\end_inset

stack_exch(value) 
\end_layout

\begin_layout Standard
Exchanges a value with the top of the stack, and returns a reference to
 the parameter (with the new value).
\end_layout

\begin_layout Section
Slider Functions
\end_layout

\begin_layout Standard
For these functions, the parameter can be the variables slider1-sliderN,
 in which case that slider is refreshed.
 Otherwise, it can be a bitmask of which sliders have changed, where 1 would
 be the first slider, 2 would be the second, 4 would be the third, 32768
 being the 16th slider, and so on.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
slider!sliderchange
\end_layout

\end_inset

sliderchange(mask or sliderX)
\end_layout

\begin_layout Standard
The sliderchange() function provides a facility for you to notify REAPER/JS
 that you have changed a sliderX variable so that it can update the display.
 This function is not necessary to call from the @slider code section, it
 is provided so that other code sections can update the sliders.
 Note that this function only updates the display, it does not send an automatio
n message to the host.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\family typewriter
\size footnotesize
sliderchange(slider4);
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\family typewriter
\size footnotesize
sliderchange(2 ^ sliderindex);
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
\begin_inset Index idx
status open

\begin_layout Plain Layout
slider!slider_automate
\end_layout

\end_inset

slider_automate(mask or sliderX)
\end_layout

\begin_layout Standard
The slider_automate() function provides a facility for you to notify REAPER/JS
 that you have changed a sliderX variable so that it can update the display,
 and record the move as automation.
 This function is not necessary to call from the @slider code section, it
 is provided so that other code sections can write programmatic automation
 messages.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\family typewriter
\size footnotesize
slider_automate(slider4);
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\family typewriter
\size footnotesize
slider_automate(2 ^ sliderindex);
\end_layout

\begin_layout Chapter
File I/O and Serialization
\end_layout

\begin_layout Standard
The following functions can be used in @serialize or in other sections
\end_layout

\begin_layout Section
Using with @serialize
\end_layout

\begin_layout Standard
Pass 0 as a handle to various file_*() functions, but do not call file_open()
 or file_close().
 Simple @serialize code will often appear the same for read and write, as
 file_var(0,x) will read/write x depending on the mode.
 If you want to have different logic per mode, you can check file_avail(0)>=0
 to determine if it is in read mode.
\end_layout

\begin_layout Section
Using in other sections
\end_layout

\begin_layout Standard
file_open() and file_close() can be used to open files for reading in any
 section.
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
file_open(index or slider) 
\end_layout

\begin_layout Standard
Opens a file from either the effect filename list or from a file slider,
 or from a string (REAPER 4.59+).
 Once open, you may use all of the file functions available.
 Be sure to close the file handle when done with it, using file_close().
 The search path for finding files depends on the method used, but generally
 speaking in 4.59+ it will look in the same path as the current effect, then
 in the JS Data/ directory.
 If file_open() fails, it will return < 0 (usually -1).
 
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

filename:0,myfile.wav 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

handle = file_open(0);
\family default
\size default
 
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

slider1:/mydata:mydef.wav:WAV File 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

handle = file_open(slider1); 
\end_layout

\begin_layout Standard
Example (REAPER 4.59+): 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

handle = file_open(string); 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
file_close(handle) 
\end_layout

\begin_layout Standard
Closes a file opened with file_open().
 
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

file_close(handle); 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
file_rewind(handle) 
\end_layout

\begin_layout Standard
Use this to rewind the current file to the beginning, to re-read the file
 etc.
 
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

file_rewind(handle); 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
file_var(handle,variable)
\family default
\size default
 
\end_layout

\begin_layout Standard
This reads (or writes if in a @serialize write) the variable from(to) the
 current file.
 • file_mem(handle,offset, length) Example: amt=file_mem(handle,offset,len);
 This reads (or writes) the block of local memory from(to) the current file.
 Returns the actual number of items read (or written).
 
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

file_var(handle,myVar);
\family default
\size default
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
file_avail(handle)
\family default
\size default
 
\end_layout

\begin_layout Standard
Returns the number of items remaining in the file, if it is in read mode.
 Returns < 0 if in write mode.
 If the file is in text mode (file_text(handle) returns TRUE), then the
 return value is simply 0 if EOF, 1 if not EOF.
 
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

len=file_avail(handle);
\family default
\size default
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
file_riff(handle,nch,samplrate) 
\end_layout

\begin_layout Standard
If the file was a RIFF WAV file, or a valid .OGG Vorbis file, this will set
 the first parameter to the number of channels, and the second to the sample
 rate.
 
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

file_riff(handle,nch,samplrate); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

nch ? file_mem(handle,0,file_avail(0));
\family default
\size default
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
file_text(handle,istext) 
\end_layout

\begin_layout Standard
If the file was a text file (and ended in .txt), this will return 1.
 If you need to use different file_avail() logic for text files (you often
 will), you can query it this way.
 Text file notes Note that if in an extended file-slider code section, and
 the extension of the file is .txt, it will read one line at a time, ignoring
 non-number lines.
 Note that file_avail() should be called to check for EOF after each read,
 and if it returns 0, the last file_var() should be ignored.
 You can also use file_mem(offs,bignum) and it will read the maximum available.
 The format of each line in the text file can be either a floating point
 number, a binary number beginning with 'b', i.e.
 b0101010111, or a hexadecimal number beginning with 'x', i.e.
 xDEADF000.
 Additionally text files can create their own symbolic constants (using
 =), and combine them using basic +, - , |, & etc operators.
 
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

istext=file_text(handle); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

istext ? use_diff_avail syntax;
\family default
\size default
 
\end_layout

\begin_layout Subsection

\family typewriter
\size normal
file_string(handle,str) -- REAPER 4.59+ 
\end_layout

\begin_layout Standard
Reads or writes a string from/to the file handle.
 If operating on a normal file, the string will be a line of text (possibly
 including newline or other characters).
 If in @serialize, the string will be encoded as a blob with length, which
 means that it is binary-safe (you can include NUL characters within the
 string etc).
\end_layout

\begin_layout Chapter
User Defined Functions and Namespace Pseudo-objects
\end_layout

\begin_layout Standard
JS now supports user defined functions, as well as some basic object style
 data access.
 Functions can be defined anywhere in top level code (i.e.
 not within an existing () block, but before or after existing code), and
 in any section, although functions defined in @init can be used from other
 sections (whereas functions defined in other sections are local to those
 sections).
 Functions are not able to be called recursively -- this is enforced by
 functions only being able to call functions that are declared before the
 current function, and functions not being able to call themselves.
 Functions may have 0 to 40 parameters.
 To define a function, use the following syntax: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
function getSampleRate() 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

srate; // return srate 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
function mySine(x) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

// taylor approximation 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x - (x^3)/(3*2) + (x^5)/(5*4*3*2) - (x^7)/(7*6*5*4*3*2) + (x^9)/(9*8*7*6*5*4*3*2
); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
function calculateSomething(x y) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x += mySine(y); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

x/y; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
);
\family default
\size default
 
\end_layout

\begin_layout Standard
Which would then be callable from other code, such as: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
y = mySine($pi * 18000 / getSampleRate()); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
z = calculateSomething(1,2);
\end_layout

\begin_layout Standard
Note that the parameters for functions are private to the function, and
 will not affect global variables.
 If you need more private variables for a function, you can declare additional
 variables using a local() statement between the function declaration and
 the body of the function.
 Variables declared in the local() statement will be local to that function,
 and persist across calls of the function (though calls to a function from
 two different sections (such as @init and @sample) will have two different
 local states.
 
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
function mySine(x) local(lastreq lastvalue) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

lastreq != x ? ( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

lastreq = x; // save last input 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

// taylor approximation
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

lastvalue = x - (x^3)/(3*2) + (x^5)/(5*4*3*2) - (x^7)/(7*6*5*4*3*2) + (x^9)/(9*8
*7*6*5*4*3*2); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

lastvalue; // result of function is cached value 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
); 
\end_layout

\begin_layout Standard
In the above example, mySine() will cache the last value used and not perform
 the calculation if the cached value is available.
 Note that the local variables are initialized to 0, which happens to work
 for this demonstration but if it was myCosine(), additional logic would
 be needed.
 JS also supports relative namespaces on global variables, allowing for
 pseudo object style programming.
 Accessing the relative namespace is accomplished either by using a "this."
 prefix for variable/function names, or by using the instance() declaration
 in the function definition for variable names: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
function set_foo(x) instance(foo) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

foo = x; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
// or 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
function set_foo(x) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

this.foo = x; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
whatever.set_foo(32); // whatever.foo = 32; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
set_foo(32); // set_foo.foo = 32; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
function test2() 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

this.set_foo(32); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
whatever.test2(); // whatever.foo = 32
\family default
\size default
 
\end_layout

\begin_layout Standard
Additionally functions can use the "this.." prefix for navigating up the namespace
 hierarchy, such as: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
function set_par_foo(x) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

this..foo = x; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
a.set_par_foo(1); // sets foo (global) to 1 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
a.b.set_par_foo(1); // sets a.foo to 1
\end_layout

\begin_layout Chapter
Graphics
\end_layout

\begin_layout Standard
Effects can specify a @gfx code section, from which the effect can draw
 its own custom UI and/or analysis display.
 These functions and variables must only be used from the @gfx section.
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_lineto
\end_layout

\end_inset

gfx_lineto(x,y,aa)
\end_layout

\begin_layout Standard
Draws a line from gfx_x,gfx_y to x,y.
 if aa is 0.5 or greater, then antialiasing is used.
 Updates gfx_x and gfx_y to x,y.
 The aa parameter is optional.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_line
\end_layout

\end_inset

gfx_line(x,y,x2,y2[,aa])
\end_layout

\begin_layout Standard
Draws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater,
 it will be antialiased.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_rectto
\end_layout

\end_inset

gfx_rectto(x,y) 
\end_layout

\begin_layout Standard
Fills a rectangle from gfx_x,gfx_y to x,y.
 Updates gfx_x,gfx_y to x,y.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_rect
\end_layout

\end_inset

gfx_rect(x,y,w,h)
\end_layout

\begin_layout Standard
Fills a rectangle at x,y, w,h pixels in dimension.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_setpixel
\end_layout

\end_inset

gfx_setpixel(r,g,b) 
\end_layout

\begin_layout Standard
Writes a pixel of r,g,b to gfx_x,gfx_y.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_getpixel
\end_layout

\end_inset

gfx_getpixel(r,g,b) 
\end_layout

\begin_layout Standard
Gets the value of the pixel at gfx_x,gfx_y into r,g,b.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_drawnumber
\end_layout

\end_inset

gfx_drawnumber(n,ndigits) 
\end_layout

\begin_layout Standard
Draws the number "n" with "ndigits" of precision to gfx_x, gfx_y, and updates
 gfx_x to the right side of the drawing.
 The text height is gfx_texth 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_drawchar
\end_layout

\end_inset

gfx_drawchar($'c') 
\end_layout

\begin_layout Standard
Draws the character 'c' (can be a numeric ASCII code as well), to gfx_x,
 gfx_y, and moves gfx_x over by the size of the character.
 
\end_layout

\begin_layout Subsection*
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_drawstr
\end_layout

\end_inset

gfx_drawstr(str)
\end_layout

\begin_layout Standard
Draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent
 draws will occur in a similar place: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
gfx_drawstr("a"); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
gfx_drawstr("b"); 
\end_layout

\begin_layout Standard
will look about the same as: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
gfx_drawstr("ab");
\family default
\size default
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_measurestr
\end_layout

\end_inset

gfx_measurestr(str,w,h)
\end_layout

\begin_layout Standard
Measures the drawing dimensions of a string with the current font (as set
 by gfx_setfont).
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_setfont
\end_layout

\end_inset

gfx_setfont(idx[,fontface, sz, flags])
\end_layout

\begin_layout Standard
Can select a font and optionally configure it.
 idx=0 for default bitmapped font, no configuration is possible for this
 font.
 idx=1..16 for a configurable font, specify font face such as "Arial", sz
 of 8-100, and optionally specify flags, which is a multibyte character,
 which can include 'i' for italics, 'u' for underline, or- 19 - 'b' for
 bold.
 These flags may or may not be supported depending on the font and OS.
 After calling gfx_setfont, gfx_texth may be updated to reflect the new
 average line height.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_getfont
\end_layout

\end_inset

gfx_getfont()
\end_layout

\begin_layout Standard
Returns current font index.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_printf
\end_layout

\end_inset

gfx_printf(str, ...) 
\end_layout

\begin_layout Standard
Formats and draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y accordingly
 (the latter only if the formatted string contains newline).
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_blurto
\end_layout

\end_inset

gfx_blurto(x,y)
\end_layout

\begin_layout Standard
Blurs the region of the screen between gfx_x,gfx_y and x,y, and updates
 gfx_x,gfx_y to x,y.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_blit
\end_layout

\end_inset

gfx_blit(source, scale, rotation)
\end_layout

\begin_layout Standard
If three parameters are specified, copies the entirety of the source bitmap
 to gfx_x,gfx_y using current opacity and copy mode (set with gfx_a, gfx_mode).
 You can specify scale (1.0 is unscaled) and rotation (0.0 is not rotated,
 angles are in radians).
 For the "source" parameter specify -1 to use the main framebuffer as source,
 or 0..127 to use the image specified (or PNG file in a filename: line).
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_blit
\end_layout

\end_inset

gfx_blit(source, scale, rotation[, srcx, srcy, srcw, srch, destx, desty,
 destw, desth, rotxoffs, rotyoffs])
\end_layout

\begin_layout Standard
Srcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default
 to image size), destx/desty/destw/desth specify dest rectangle (if not
 specified, these will default to reasonable defaults -- destw/desth default
 to srcw/srch * scale).
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_blitext
\end_layout

\end_inset

gfx_blitext(source, coordinatelist, rotation)
\end_layout

\begin_layout Standard
This is a version of gfx_blit which takes many of its parameters via a buffer
 rather than direct parameters.
 For the "source" parameter specify -1 to use the main framebuffer as source,
 or 0..127 to use the image specified (or PNG file in a filename: line).
 coordinatelist should be an index to memory where a list of 10 parameters
 are stored, such as: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist=1000; // use memory slots 1000-1009 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[0]=source_x; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[1]=source_y; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[2]=source_w; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[3]=source_h; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[4]=dest_x; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[5]=dest_y; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[6]=dest_w; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[7]=dest_h; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[8]=rotation_x_offset; // only used if rotation is set, represents
 offset from center of image 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
coordinatelist[9]=rotation_y_offset; // only used if rotation is set, represents
 offset from center of image 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
gfx_blitext(img,coordinatelist,angle);
\family default
\size default
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_getimgdim
\end_layout

\end_inset

gfx_getimgdim(image, w, h)
\end_layout

\begin_layout Standard
Retrieves the dimensions of image (representing a filename: index number)
 into w and h.
 Sets these values to 0 if an image failed loading (or if the filename index
 is invalid).
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_setimgdim
\end_layout

\end_inset

gfx_setimgdim(image, w,h)
\end_layout

\begin_layout Standard
Resize image referenced by index 0..127, width and height must be 0-2048.
 The contents of the image will be undefined after the resize.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_loadimg
\end_layout

\end_inset

gfx_loadimg(image, filename)
\end_layout

\begin_layout Standard
Load image from filename (see strings) into slot 0..127 specified by image.
 Returns the image index if success, otherwise -1 if failure.
 The image will be resized to the dimensions of the image file.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_gradrect
\end_layout

\end_inset

gfx_gradrect(x,y,w,h, r,g,b,a[, drdx, dgdx, dbdx, dadx, drdy, dgdy, dbdy,
 dady])
\end_layout

\begin_layout Standard
Fills a gradient rectangle with the color and alpha specified.
 drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved
 to the right, drdy-dady are the adjustment applied for each pixel moved
 toward the bottom.
 Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_muladdrect
\end_layout

\end_inset

gfx_muladdrect(x,y,w,h, mul_r, mul_g, mul_b[, mul_a, add_r, add_g, add_b,
 add_a])
\end_layout

\begin_layout Standard
Multiplies each pixel by mul_* and adds add_*, and updates in-place.
 Useful for changing brightness/contrast, or other effects.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_deltablit
\end_layout

\end_inset

gfx_deltablit(srcimg,srcx,srcy,srcw,srch, destx, desty, destw, desth, dsdx,
 dtdx, dsdy, dtdy, dsdxdy, dtdxdy)
\end_layout

\begin_layout Standard
Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth).
 Source texture coordinates are s/t, dsdx represents the change in s coordinate
 for each x pixel, dtdy represents the change in t coordinate for each y
 pixel, etc.
 dsdxdy represents the change in dsdx for each line.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_transformblit
\end_layout

\end_inset

gfx_transformblit(srcimg, destx, desty, destw, desth, div_w, div_h, table)
\end_layout

\begin_layout Standard
Blits to destination at (destx,desty), size (destw,desth).
 div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div
_h values (this table must not cross a 65536 item boundary).
 Each pair in the table represents a S,T coordinate in the source image,
 and the table is treated as a left-right, top-bottom list of texture coordinate
s, which will then be rendered to the destination.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_circle
\end_layout

\end_inset

gfx_circle(x,y,r[,fill,antialias])
\end_layout

\begin_layout Standard
Draws a circle, optionally filling/antialiasing.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_roundrect
\end_layout

\end_inset

gfx_roundrect(x,y,w,h,radius[,antialias])
\end_layout

\begin_layout Standard
Draws a rectangle with rounded corners.
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_arc
\end_layout

\end_inset

gfx_arc(x,y,r, ang1, ang2[,antialias])
\end_layout

\begin_layout Standard
Draws an arc of the circle centered at x,y, with ang1/ang2 being specified
 in radians.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_triangle
\end_layout

\end_inset

gfx_triangle(x1,y1,x2,y2,x3,y3[,x4,y4,...])
\end_layout

\begin_layout Standard
Fills a triangle (or a convex polygon if more than 3 pairs of coordinates
 are specified).
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_getchar
\end_layout

\end_inset

gfx_getchar([char])
\end_layout

\begin_layout Standard
If no parameter or zero is passed, returns a character from the plug-in
 window's keyboard queue.
 The return value will be less than 1 if no value is available.
 If char is passed and nonzero, returns whether that key is currently down.
 Common values are standard ASCII, such as 'a', 'A', '=' and '1', but for
 many keys multi-byte values are used, including 'home', 'up', 'down', 'left',
 'rght', 'f1'..
 'f12', 'pgup', 'pgdn', 'ins', and 'del'.
 If the user has the "send all keyboard input to plug-in" option set, then
 many modified and special keys will be returned, including: 
\end_layout

\begin_layout Standard
Ctrl/Cmd+A..Ctrl+Z as 1..26 
\end_layout

\begin_layout Standard
Ctrl/Cmd+Alt+A..Z as 257..282, 
\end_layout

\begin_layout Standard
Alt+A..Z as 'A'+256..'Z'+256 
\end_layout

\begin_layout Standard
27 for ESC 
\end_layout

\begin_layout Standard
13 for Enter 
\end_layout

\begin_layout Standard
' ' for space 
\end_layout

\begin_layout Standard
The plug-in can specify a line (before code sections): 
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
options:!want_all_kb
\end_layout

\end_inset

options:want_all_kb 
\end_layout

\begin_layout Standard
which will change the "send all keyboard input to plug-in" option to be
 on by default for new instances of the plug-in.
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_r
\end_layout

\end_inset

gfx_r, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_g
\end_layout

\end_inset

gfx_g, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_b
\end_layout

\end_inset

gfx_b, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_a
\end_layout

\end_inset

gfx_a 
\end_layout

\begin_layout Standard
These represent the current red, green, blue, and alpha components used
 by drawing operations (0.0..1.0).
 
\end_layout

\begin_layout Subsection*
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_w
\end_layout

\end_inset

gfx_w, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_h
\end_layout

\end_inset

gfx_h 
\end_layout

\begin_layout Standard
These are set to the current width and height of the UI framebuffer.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_x
\end_layout

\end_inset

gfx_x, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_y
\end_layout

\end_inset

gfx_y 
\end_layout

\begin_layout Standard
These set the "current" graphics position in x,y.
 You can set these yourselves, and many of the drawing functions update
 them as well.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_mode
\end_layout

\end_inset

gfx_mode 
\end_layout

\begin_layout Standard
Set to 0 for default options.
 Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx_a
 to negative and use gfx_mode as additive).
 Add 2.0 to disable source alpha for gfx_blit().
 Add 4.0 to disable filtering for gfx_blit().
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_clear
\end_layout

\end_inset

gfx_clear 
\end_layout

\begin_layout Standard
If set to a value greater than -1.0, this will result in the framebuffer
 being cleared to that color.
 the color for this one is packed RGB (0..255), i.e.
 red+green*256+blue*65536.
 The default is 0 (black).
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_dest
\end_layout

\end_inset

gfx_dest
\end_layout

\begin_layout Standard
Defaults to -1, set to 0..127 to have drawing operations go to an offscreen
 buffer (or loaded image).
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
gfx!_texth
\end_layout

\end_inset

gfx_texth 
\end_layout

\begin_layout Standard
Set to the height of a line of text in the current font.
 Do not modify this variable.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
mouse_x
\end_layout

\end_inset

mouse_x, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
mouse_y
\end_layout

\end_inset

mouse_y 
\end_layout

\begin_layout Standard
mouse_x and mouse_y are set to the coordinates of the mouse within the graphics
 area of the window.
 
\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
mouse_cap
\end_layout

\end_inset

mouse_cap 
\end_layout

\begin_layout Standard
mouse_cap is a bitfield of mouse and keyboard modifier state.
 
\end_layout

\begin_layout Standard
1: left mouse button 
\end_layout

\begin_layout Standard
2: right mouse button 
\end_layout

\begin_layout Standard
4: Control key (Windows), Command key (OSX) 
\end_layout

\begin_layout Standard
8: Shift key 
\end_layout

\begin_layout Standard
16: Alt key (Windows), Option key (OSX) 
\end_layout

\begin_layout Standard
32: Windows key (Windows), Control key (OSX) 
\end_layout

\begin_layout Standard
64: middle mouse button
\end_layout

\begin_layout Subsection*
\begin_inset Index idx
status open

\begin_layout Plain Layout
mouse_wheel
\end_layout

\end_inset

mouse_wheel, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
mouse_hwheel
\end_layout

\end_inset

mouse_hwheel
\end_layout

\begin_layout Standard
mouse wheel (and horizontal wheel) positions.
 These will change typically by 120 or a multiple thereof, the caller should
 clear the state to 0 after reading it.
\end_layout

\begin_layout Chapter
Strings
\end_layout

\begin_layout Standard
Strings can be specified as literals using quotes, such as "This is a test
 string".
 Much of the syntax mirrors that of C: you must escape quotes with backslashes
 to put them in strings ("He said 
\backslash
"hello, world
\backslash
" to me"), multiple literal strings will be automatically concatenated by
 the compiler.
 Unlike C, quotes can span multiple lines.
 There is a soft limit on the size of each string: attempts to grow a string
 past about 16KB will result in the string not being modified.
 Strings are always referred to by a number, so one can reference a string
 using a normal JS variable: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
x = "hello world"; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
gfx_drawstr(x);
\family default
\size default
 
\end_layout

\begin_layout Standard
Literal strings are immutable (meaning they cannot be modified).
 If you wish to have mutable strings, you have three choices: 
\end_layout

\begin_layout Standard
You can use the fixed values of 0-1023: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
x = 50; // string slot 50 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
strcpy(x, "hello "); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
strcat(x, "world"); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
gfx_drawstr(x); 
\end_layout

\begin_layout Standard
This mode is useful if you need to build or load a table of strings.
 
\end_layout

\begin_layout Standard
You can use # to get an instance of a temporary string: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
x = #; strcpy(x, "hello "); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
strcat(x, "world"); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
gfx_drawstr(x); 
\end_layout

\begin_layout Standard
Note that the scope of these temporary instances is very limited and unpredictab
le, and their initial values are undefined.
 
\end_layout

\begin_layout Standard
Finally, you can use named strings, which are the equivalent of normal variables
: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
x = #myString; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
strcpy(x, "hello world"); 
\end_layout

\begin_layout Standard
The value of named strings is defined to be empty at script load, and to
 persist throughout the life of your script.
 There is also a shortcut to assign/append to named strings: 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
#myString = "hello "; // same as strcpy(#myString, "hello "); 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
#myString += "world"; // same as strcat(#myString, "world");
\end_layout

\begin_layout Chapter
MIDI Functions
\end_layout

\begin_layout Standard
It is highly recommended that any MIDI event processing take place in @block,
 but sending MIDI events can also take place in @sample.
\end_layout

\begin_layout Subsection
midisend(offset,msg1,msg2) 
\begin_inset Newline newline
\end_inset

midisend(offset,msg1,msg2 + (msg3 * 256)) 
\begin_inset Newline newline
\end_inset

midisend(offset,msg1,msg2,msg3)
\end_layout

\begin_layout Standard
Sends a 2 or 3 byte MIDI message.
 If only three parameters are specified, the second lowest byte of the third
 parameter will be used as a third byte in the MIDI message.
 Returns 0 on failure, otherwise msg1.
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
midisend(0, $x90, 69, 127); // send note 69 to channel 0 at velocity 127
 (new syntax) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
midisend(0, $x90, 69+(127*256)); // send note 69 to channel 0 at velocity
 127 (old synatx) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
midisend(10,$xD4,50); // set channel pressure on channel 4 to 50, at 10
 samples into current block
\family default
\size default
 
\end_layout

\begin_layout Subsection
midisend_buf(offset,buf, len)
\end_layout

\begin_layout Standard
Sends a variable length MIDI message.
 Can be used to send normal MIDI messages, or SysEx messages.
 When sending SysEx, logic is used to automatically add leading 0xf0 and
 trailing 0xf7 bytes, if necessary, but if you are sending sysEx and in
 doubt you should include those bytes (particularly if sending very short
 SysEx messages).
 Returns the length sent, or 0 on error.
 This function is very similar to midisyx, but preferable in that it can
 be used to send non-SysEx messages and has no restrictions relating to
 the alignment of the buffer being sent.
\end_layout

\begin_layout Standard
buf = 100000; 
\end_layout

\begin_layout Standard
buf[0] = 0x90; 
\end_layout

\begin_layout Standard
buf[1] = 69; 
\end_layout

\begin_layout Standard
buf[2] = 127; // send (at sample offset 10) note-on channel 0, note 69,
 velocity 127 
\end_layout

\begin_layout Standard
midisend_buf(10,buf,3); 
\end_layout

\begin_layout Standard
buf[0] = 0xf0;
\end_layout

\begin_layout Standard
buf[1] = 0xaa; 
\end_layout

\begin_layout Standard
...
 
\end_layout

\begin_layout Standard
buf[n] = 0xf7; midisend_buf(0,buf,n+1); // send sysex 0xf0 0xaa ..
 ..
 ..
 ..
 0xf7 
\end_layout

\begin_layout Subsection
midisend_str(offset,string)
\end_layout

\begin_layout Standard
Sends a variable length MIDI message from a string.
 Can be used to send normal MIDI messages, or SysEx messages.
 When sending SysEx, logic is used to automatically add leading 0xf0 and
 trailing 0xf7 bytes, if- 24 - necessary, but if you are sending sysEx and
 in doubt you should include those bytes (particularly if sending very short
 SysEx messages).
 Returns the length sent, or 0 on error.
 
\end_layout

\begin_layout Standard
// send at sample offset 10, note-on, note 17, velocity 127 
\end_layout

\begin_layout Standard
midisend_str(10,"
\backslash
x90
\backslash
x11
\backslash
x7f"); 
\end_layout

\begin_layout Subsection
midirecv(offset,msg1,msg23) 
\begin_inset Newline newline
\end_inset

midirecv(offset,msg1,msg2,msg3)
\end_layout

\begin_layout Standard
@block 
\end_layout

\begin_layout Standard
while (midirecv(offset,msg1,msg2,msg3)) ( 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

msg1==$x90 && msg3!=0 ? ( 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

noteon_cnt+=1; // count note-ons 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

) : ( 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

midisend(offset,msg1,msg2,msg3); // passthrough other events 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

) 
\end_layout

\begin_layout Standard
); 
\end_layout

\begin_layout Standard
The above example will filter all noteons on channel 0, passing through
 other events.
 The construct above is commonly used -- if any of the midirecv*() functions
 are called, one must always get all events and send any events desired
 to be passed through.
 If only three parameters are passed to midirecv, the third parameter will
 receive both the second and third bytes of a MIDI message (second byte
 + (third byte * 256)).
 Calling midirecv() will automatically passthrough any SysEx events encountered;
 if you wish to process SysEx events, please use midirecv_buf() instead.
 
\end_layout

\begin_layout Subsection
midirecv_buf(offset,buf, maxlen) 
\end_layout

\begin_layout Standard
Receives a message to a buffer, including any SysEx messages whose length
 is not more than maxlen.
 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
@block 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
buf = 10000; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
maxlen = 65536; 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
while ((recvlen = midirecv_buf(offset,buf,maxlen)) > 0) ( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

recvlen <= 3 && buf[0] == $x90 && buf[2] !=0 ? ( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

noteon_cnt+=1; // count note-ons 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

) : ( 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

midisend_buf(offset,buf,recvlen); // passthrough other events 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

) 
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
);
\end_layout

\begin_layout Standard
The above example will filter all noteons on channel 0, passing through
 other events.
 The construct above is commonly used -- if any of the midirecv*() functions,
 one must always get all events and send any events desired to be passed
 through.
 If maxlen is smaller than the length of the MIDI message, the MIDI message
 will automatically be passed through.
 For one and two byte MIDI messages (such as channel pressure), the length
 returned may or may not be 2 or 3.
 
\end_layout

\begin_layout Subsection
midirecv_str(offset, string)
\end_layout

\begin_layout Standard
Receives a MIDI or SysEx message to a string.
 
\end_layout

\begin_layout Standard
@block 
\end_layout

\begin_layout Standard
while (midirecv_str(offset,#str)) ( 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

strlen(#str) <= 3 && str_getchar(#str,0) == $x90 && str_getchar(#str,2)
 != 0 ? ( 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

noteon_cnt+=1; // count note-ons 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

) : ( 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

midisend_str(offset,#str); 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

) 
\end_layout

\begin_layout Standard
); 
\end_layout

\begin_layout Standard
The above example will filter all noteons on channel 0, passing through
 other events.
 The construct above is commonly used -- if any of the midirecv*() functions,
 one must always get all events and send any events desired to be passed
 through.
 midirecv_str() will return the length of the message on success, or 0 on
 failure.
 On failure (no more messages), the value of the string passed in is undefined.
 strlen(#str) may be 1,2 or 3 for one or two byte MIDI messages.
 
\end_layout

\begin_layout Section
Midi Bus Support
\end_layout

\begin_layout Standard
REAPER supports multiple MIDI buses, JSFX plug-ins can (but do not by default)
 access all 16 buses.
\end_layout

\begin_layout Subsection
ext_midi_bus
\end_layout

\begin_layout Standard
Set to 1.0 in @init to enable support for MIDI buses (by default buses other
 than bus 0 will be passed through).
 
\end_layout

\begin_layout Subsection
midi_bus
\end_layout

\begin_layout Standard
If ext_midi_bus is set, this will be set by midirecv() to the MIDI bus of
 the event, and will be used by midisend() et al to route the MIDI event
 accordingly.
 Valid values are 0..15.
\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
